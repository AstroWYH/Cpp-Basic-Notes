### **内存对齐的定义**
内存对齐是指数据在内存中存储时，其起始地址必须是某个特定值（通常是数据类型大小的整数倍）的规则。例如，`int`类型（4字节）的变量必须存储在地址为4的倍数的位置（如0x0000、0x0004等），而非随意存放（如0x0003）。

### **目的**
1. **性能优化**  
   CPU访问对齐的内存时只需一次操作，而未对齐的数据可能需要多次读取和拼接。例如，一个未对齐的`int`变量存储在地址0x0003，32位CPU需先读取0x0000-0x0003和0x0004-0x0007两块数据，再拼接出完整的`int`，效率低下。

2. **硬件兼容性**  
   某些架构（如ARM、MIPS）会直接拒绝访问未对齐数据或触发硬件异常。内存对齐确保代码可移植性。

3. **减少内存碎片**  
   对齐规则通过填充字节（Padding）优化内存布局，避免因数据跨边界存储导致的碎片化。

---

### **示例说明**
#### **例1：结构体内存对齐**
以下结构体在默认对齐（通常4字节）下的内存分配：
```c
struct Example {
    char a;  // 1字节，起始地址0
    int b;   // 4字节，需对齐到4的倍数，起始地址4（填充3字节）
    char c;  // 1字节，起始地址8
};
// 总大小：1 + 3（填充） + 4 + 1 = 9字节，但需整体对齐到4的倍数，最终为12字节。
```

#### **例2：修改对齐方式**
通过`#pragma pack(1)`强制1字节对齐，取消填充：
```c
#pragma pack(1)
struct Example {
    char a;  // 1字节
    int b;   // 4字节，紧接存放
    char c;  // 1字节
};
// 总大小：1 + 4 + 1 = 6字节，但可能降低CPU访问效率。
```

#### **例3：跨平台差异**
- **32位系统**：`double`（8字节）默认对齐到4字节边界。  
- **64位系统**：`double`对齐到8字节边界。未对齐时，32位系统可能分两次读取，而64位系统直接报错。

---

### **总结**
内存对齐通过牺牲少量空间（填充字节）换取性能和兼容性，是编译器与硬件协作的关键机制。开发者可通过`#pragma pack`或`__attribute__((aligned))`手动调整对齐策略。
